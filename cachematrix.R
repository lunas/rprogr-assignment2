## A function makeCacheMatrix that creates an R object that can preserve a 
##   matrix and its inverse and features methods to get/set those two internal
##   objects.
## A second function cacheSolve that makes use of an object created by 
##   makeCacheMatrix to get the inverse of its matrix if it already exists,
##   so the calculation of the inverse doesn't need to be repeated.

# Creates an R object (a list) obj that encloses the matrix passed to the 
# function as parameter and also the inverse of this matrix if it is set with
# obj$set.inverse(I).
# Both the enclosed matrix and its inverse can be retrieved with obj$get and 
# obj$get.inverse, respectively.
# 
# Parameter mat: an invertible matrix. If omitted, an empty matrix is used.
# Returns a list with the elements set, get, get.inverse, set.inverse, 
#   all of them functions.
makeCacheMatrix <- function(mat = matrix()) {  
  mat.inverse <- NULL
  list(
    set = function(m) {
      mat <<- m
      mat.inverse <<- NULL
    },
    get = function() mat,
    set.inverse = function(inverse) mat.inverse <<- inverse,
    get.inverse = function() mat.inverse
  )
}


# Returns the inverse of the matrix that is retrieved from the object mat 
# passed to the function. This object must be of the type generated by 
# makeCacheMatrix, i.e. mat$get() must return the original matrix, 
# mat$get.inverse() must return the inverse of this original matrix or 
# NULL, and mat$set.inverse(inv.mat) must store inv.mat within obj.
# cacheSolve assumes that the matrix in mat is invertible.
# Parameter mat: an object generated by makeCacheMatrix, as described above
# Returns: inverse of the matrix stored in mat
cacheSolve <- function(mat, ...) {        
  mat.inverse <- mat$get.inverse()
  if(!is.null(mat.inverse)) {
    message("getting cached data")
    return(mat.inverse)
  }
  matrix.data <- mat$get()
  mat.inverse <- solve(matrix.data, ...)
  mat$set.inverse(mat.inverse)
  mat.inverse
}
